# -*- coding: utf-8 -*-
"""EC306 U.S. unemployment rate forecast.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ObyZlGbyAnOstGknvW0UZI5koY4iLWVt
"""

###import
import numpy as np
import pandas as pd
import datetime as dt
import matplotlib.pylab as plt
from scipy.stats import norm
import math
import seaborn as sns
import time

df=pd.read_excel("/content/UNRATE.xlsx", sheet_name='Monthly')

df

df.rename(columns={"observation_date":"date","UNRATE":"unemployment_rate"}, inplace=True)
print(type(df.date[0]))

##Check missing values in all columns
missing_values=df.isnull().sum()
print(missing_values)

df = df.dropna(subset=['unemployment_rate'])
missing_values=df.isnull().sum()
print(missing_values)

df

today = pd.Timestamp('2026-01-09')  # Adjust or use pd.Timestamp('now')

# Days since each observation (older = larger number)
df['days_ago'] = (today - df['date']).dt.days
df['days_ago'] = df['days_ago'].clip(lower=0)  # No negative days

# Exponential decay: weight = exp(-lambda * days_ago)
half_life = 365  # e.g., 1 year; adjust as needed
decay_lambda = np.log(2) / half_life
unemployment_weight= np.exp(-decay_lambda * df['days_ago'])

# Normalize to sum to 1
unemployment_weight /= (unemployment_weight.sum())

print(df['days_ago'])
print(unemployment_weight.sum())
print(unemployment_weight)

loggrowth=np.log(df["unemployment_rate"]/(df["unemployment_rate"].shift(1)))
loggrowth
rate_change=loggrowth.dropna()
print(rate_change)

#Function of weighted std和 mean:
def weighted_function(values, weights):
    values = np.array(values)
    weights = np.array(weights)

    if weights.sum() == 0:
        return np.nan

    weighted_mean = np.average(values, weights=weights)
    variance = np.average((values - weighted_mean)**2, weights=weights)
    return weighted_mean, np.sqrt(variance)

average_change, change_std = weighted_function(rate_change, unemployment_weight[0:934])
print(average_change)
print(change_std)

###Monte-Carlo Simulation settings
#randomize via normal ditribution
def shock(mean, std):
  return np.random.normal(mean, std)


#Return the result of running the one-time simulation，unemployment_rate after X months，generate random samples
def portfolio_pl(mean, std, months, initial_rate):
  esti_unemployment_rate=initial_rate

  for month in range(months):
    z_score=shock(mean, std)
    esti_unemployment_rate=esti_unemployment_rate * np.exp(mean + z_score * std)
  return esti_unemployment_rate

###Running
months=3
initial_rate=df.unemployment_rate[df["date"] == "2025-12-01"]
simulation_times=300000
#load simulation results
simulation_result=[]
for i in range(simulation_times):
  pl=portfolio_pl(average_change, change_std, months, initial_rate)
  simulation_result.append(pl.iloc[0])

simulation_result

#10% Forecast
Forecast_percentile=0.10
#X% Forecast
Outcome_10=np.percentile(simulation_result,Forecast_percentile*100)
print(Outcome_10.round(2))
###Visual
sns.histplot(simulation_result,kde=True,color='blue')
plt.xlabel(f'{months}-month unemployment rate')
plt.ylabel('Frequency')
plt.title(f'{months} month distribution of unemployment rates')
plt.axvline(x=Outcome_10,color='red',linestyle='dashed',linewidth=2,label=f'Forecast at{Forecast_percentile*100}%')
plt.legend
plt.show()

#50% Forecast
Forecast_percentile=0.50
#X% Forecast
Outcome_50=np.percentile(simulation_result,Forecast_percentile*100)
print(Outcome_50.round(2))
###Visual
sns.histplot(simulation_result,kde=True,color='blue')
plt.xlabel(f'{months}-month unemployment rate')
plt.ylabel('Frequency')
plt.title(f'{months} month distribution of unemployment rates')
plt.axvline(x=Outcome_50,color='red',linestyle='dashed',linewidth=2,label=f'Forecast at{Forecast_percentile*100}%')
plt.legend
plt.show()

#90% Forecast
Forecast_percentile=0.90
#X% Forecast
Outcome_90=np.percentile(simulation_result,Forecast_percentile*100)
print(Outcome_90.round(2))
###Visual
sns.histplot(simulation_result,kde=True,color='blue')
plt.xlabel(f'{months}-month unemployment rate')
plt.ylabel('Frequency')
plt.title(f'{months} month distribution of unemployment rates')
plt.axvline(x=Outcome_90,color='red',linestyle='dashed',linewidth=2,label=f'Forecast at{Forecast_percentile*100}%')
plt.legend
plt.show()