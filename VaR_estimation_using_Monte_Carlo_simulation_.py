# -*- coding: utf-8 -*-
"""VaR estimation using Monte Carlo Simulation .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MyjCluBDyWRLo_fNMOdo-xuPIKyPNJ92
"""

###import
import numpy as np
import pandas as pd
import datetime as dt
import matplotlib.pylab as plt
from scipy.stats import norm
import math
import seaborn as sns
import time

#pip install yfinance
import yfinance as yf

#创建研究时间范围：3 years
years=3
endDate=dt.datetime.today()
startDate=endDate-dt.timedelta(days=365*years)

print(startDate)
print(endDate)

#创建证券的代码ticker,以便从yfinance提取数据
#SPY: 标普500指数基金
#LQD: ishares inbox $ Investment Grade Coporate bond ETF
#GLD: SPDR Gold Trust
#DBC: Invesco DB Commodity Index Tracking Fund
#FXE_ Invesco CurrencyShare Euro Trust
tickers=['SPY','LQD','GLD','DBC','FXE']

#创建closePrice_df 的dataframe
#通过for loop从雅虎finance中将这几个证券的历史收盘价格下载下来
closeprice_df=pd.DataFrame()

for ticker in tickers:
  data=yf.download(ticker,startDate,endDate)
  closeprice_df[ticker]=data['Close']

closeprice_df

#通过np.log,和df.shift计算上述资产的log return，并去除NA值
logreturn=np.log(closeprice_df/closeprice_df.shift(1))
logreturn
closeprice_df=closeprice_df.dropna() #将N/A的数据去掉
logreturn=logreturn.dropna()

closeprice_df.to_csv('closeprice.csv') #通过将closeprice_df转变为csv,在excel中进行操作，验证log return 的计算
logreturn.to_csv('logreturn.csv')

print(logreturn)
print(closeprice_df)

###创建组合指标计算公式
#计算组合的协方差矩阵
portfolio_cov=logreturn.cov()
print(portfolio_cov)

#创建计算组合期望收益率的公式(用历史收益率)
def portfolio_expected_return(weights,logreturn):
  return np.sum(weights * logreturn.mean())

#创建计算组合标准差的公式
#使用@来计算矩阵相乘
def portfolio_std_deviation(weights,portfolio_cov):
  portfolio_variance=weights.T @ portfolio_cov @ weights
  return np.sqrt(portfolio_variance)

#创建组合（设置组合权重）
#设置组合初始金额
portfolio_principal=1000000 #一百万
#设置各个证券的权重，每个资产的权重都一样
ticker_weights=1/len(tickers)
portfolio_weights=pd.Series({ticker:ticker_weights for ticker in tickers})

print(portfolio_weights)

portfolioexpreturn= portfolio_expected_return(portfolio_weights,logreturn)
portfoliostandarddeviation=portfolio_std_deviation(portfolio_weights,portfolio_cov)

print(portfolioexpreturn)
print(portfoliostandarddeviation)

###蒙特卡洛模拟设置
#通过正态分布创建随机数
def z_score_rand():
  return np.random.normal(0,1)#假设distribution mean=0,标准差为1

#创建一个公式，可以返回一次蒙特卡洛模拟的情况下，portfolio在x天后的损益情况
def portfolio_pl(portfolioexpreturn,portfoliostandarddeviation,days,portfolio_principal):
  portfolio_value=portfolio_principal
  for days in range(days):
    z_score=z_score_rand()
    portfolio_value=portfolio_value* np.exp(portfolioexpreturn+z_score*portfoliostandarddeviation)
  return portfolio_value-portfolio_principal

###进行蒙特卡洛模拟
#确定计算x天后的VaR
days=5
#设置模拟次数
simulation_times=100000

#装载模拟结果
simulation_result=[]

for i in range(simulation_times):
  pl=portfolio_pl(portfolioexpreturn,portfoliostandarddeviation,days,portfolio_principal)
  simulation_result.append(pl)

simulation_result

###设置置信区间，计算VaR
confidence_interval=0.95

#通过np.percentile计算VaR值
VaR=np.percentile(simulation_result,100-confidence_interval*100)
print(VaR)
#100万美元的投资组合在10天的时间范围内有5%的可能性expected损失超过18537美元，也就是说有95%的可能性组合的损失不会超过这个数

###数据可视化
sns.histplot(simulation_result,kde=True,color='blue')
plt.xlabel(f'{days}-day portfolio earnings')
plt.ylabel('Frequency')
plt.title(f'{days} day distribution of portfolio returns')
plt.axvline(x=VaR,color='red',linestyle='dashed',linewidth=2,label=f'VaR at{confidence_interval*100}%')
plt.legend
plt.show() #这个图像的红线往右的区域就是P（x>VaR）=95%，VaR是个负值

simulation_data=pd.DataFrame(simulation_result)

print(simulation_data.mean())
print(simulation_data.std())